<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.19.1 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>The Expression System - upb.crypto Documentation</title>
<meta name="description" content="Documentation page for the upb.crypto libraries. ">



<meta property="og:type" content="website">
<meta property="og:locale" content="en">
<meta property="og:site_name" content="upb.crypto Documentation">
<meta property="og:title" content="The Expression System">
<meta property="og:url" content="http://localhost:4000/docs/expressions.html">


  <meta property="og:description" content="Documentation page for the upb.crypto libraries. ">












<link rel="canonical" href="http://localhost:4000/docs/expressions.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "http://localhost:4000/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="upb.crypto Documentation Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          upb.crypto Documentation
          
        </a>
        <ul class="visible-links"></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">Getting Started</span>
        

        
        <ul>
          
            <li><a href="/getting-started/libraries.html">Libraries Overview</a></li>
          
            <li><a href="/getting-started/installation.html">Installation</a></li>
          
            <li><a href="/getting-started/implement-elgamal.html">Example: Implementing ElGamal Encryption</a></li>
          
            <li><a href="/getting-started/benchmarking.html">Benchmarking</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Documentation</span>
        

        
        <ul>
          
            <li><a href="/docs/representations.html">Representations</a></li>
          
            <li><a href="/docs/expressions.html" class="active">Expressions</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">For Contributors</span>
        

        
        <ul>
          
            <li><a href="/contributors/snapshot_builds.html">Snapshot Builds</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="The Expression System">
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">The Expression System
</h1>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu">
  <li><a href="#group-expressions">Group Expressions</a>
    <ul>
      <li><a href="#variable-substitution-using-value-bundles">Variable Substitution using Value Bundles</a></li>
    </ul>
  </li>
  <li><a href="#boolean-expressions">Boolean Expressions</a>
    <ul>
      <li><a href="#group-equality-expressions">Group Equality Expressions</a></li>
      <li><a href="#probabilistic-and-merging">Probabilistic AND Merging</a></li>
    </ul>
  </li>
  <li><a href="#configuring-the-expression-evaluator">Configuring the Expression Evaluator</a>
    <ul>
      <li><a href="#configuring-the-multi-exponentiation-algorithms">Configuring the Multi-exponentiation Algorithms</a></li>
      <li><a href="#configuring-the-group-precomputation-phase">Configuring the Group Precomputation Phase</a></li>
      <li><a href="#configuring-the-boolean-precomputation-phase">Configuring the Boolean Precomputation Phase</a></li>
      <li><a href="#a-note-regarding-efficient-caching">A Note Regarding Efficient Caching</a></li>
    </ul>
  </li>
  <li><a href="#references">References</a></li>
</ul>

            </nav>
          </aside>
        
        <p>The expression system of the math library offers a way to do group and boolean algebra with the goal of allowing for optimizations such as the use of multi-exponentiation algorithms or rewriting algebraic terms to be more efficiently computable.</p>

<p>Expressions differ from the usual use of functions such as <code class="language-plaintext highlighter-rouge">pow()</code> or <code class="language-plaintext highlighter-rouge">op()</code> in that the result is not calculated immediately. Instead, an expression tree is built up which, when evaluated, will compute the result of the expression. This has several advantages:</p>

<ul>
  <li>The whole expression is evaluated as a single entity. This allows for automatic detection of multi-exponentiations which enables the use of efficient multi-exponentiation algorithms. These can greatly improve performance compared to performing every exponentiation on its own.</li>
  <li>The expression can be precomputed. Since it may contain variables whose value may not be known at that point in time, this precomputation can optimize the expression to allow for more efficient evaluation later, e.g. by caching powers for exponentiation algorithms.</li>
</ul>

<p>In this document we show how expressions work and what kind of optimizations are supported.</p>

<h1 id="group-expressions">Group Expressions</h1>
<p>To showcase group expressions, we want to use them to implement a concrete cryptographic scheme. We have chosen
Pointcheval and Sanders multi-message signature scheme from <a href="Section 4.2">PS16</a> for this. It is available in the <strong>upb.crypto.craco</strong> library already.</p>

<p>We start with the verification algorithm:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Given signature sigma = (sigma1, sigma2), message m = (m_0, ..., m_{r-1}), and public key pk, public parameters pp</span>
    <span class="c1">// and message length r</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sigma1</span><span class="o">.</span><span class="na">isNeutralElement</span><span class="o">())</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

    <span class="c1">// construct left side of equality check: e(sigma_1, \tilde{X} \cdot \prod{\tilde{Y}_j^{m_j}}</span>
    <span class="nc">GroupElementExpression</span> <span class="n">leftSideG2</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="na">getBilinearMap</span><span class="o">().</span><span class="na">getG2</span><span class="o">().</span><span class="na">expr</span><span class="o">();</span> <span class="c1">// neutral element of G2</span>
    <span class="n">leftSideG2</span> <span class="o">=</span> <span class="n">leftSideG2</span><span class="o">.</span><span class="na">op</span><span class="o">(</span><span class="n">pk</span><span class="o">.</span><span class="na">getTildeX</span><span class="o">());</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">;</span> <span class="o">++</span><span class="no">I</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// equivalent to leftSideG2 = leftSideG2.op(pk.getTildeYi()[j].pow(m_j));</span>
        <span class="n">leftSideG2</span> <span class="o">=</span> <span class="n">leftSideG2</span><span class="o">.</span><span class="na">opPow</span><span class="o">(</span><span class="n">pk</span><span class="o">.</span><span class="na">getTildeYi</span><span class="o">()[</span><span class="n">j</span><span class="o">],</span> <span class="n">m</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
    <span class="o">}</span>
    <span class="nc">GroupElementExpression</span> <span class="n">leftSide</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="na">getBilinearMap</span><span class="o">().</span><span class="na">expr</span><span class="o">(</span><span class="n">sigma1</span><span class="o">,</span> <span class="n">leftSideG2</span><span class="o">);</span>

    <span class="c1">// construct right side of equality check: e(sigma2, \tilde{g})</span>
    <span class="nc">GroupElementExpression</span> <span class="n">rightSide</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="na">getBilinearMap</span><span class="o">().</span><span class="na">expr</span><span class="o">(</span><span class="n">sigma2</span><span class="o">,</span> <span class="n">pk</span><span class="o">.</span><span class="na">getTildeG</span><span class="o">());</span>
    
    <span class="k">return</span> <span class="n">leftSide</span><span class="o">.</span><span class="na">evaluate</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">rightSide</span><span class="o">.</span><span class="na">evaluate</span><span class="o">());</span>
</code></pre></div></div>
<p>As you can see, only when we return the result of the two pairings are actually evaluated through the <code class="language-plaintext highlighter-rouge">evaluate()</code> call. Before that, the expression tree is built. It is barely more complex than directly computing each intermediary result. You simply need to call <code class="language-plaintext highlighter-rouge">expr()</code> on a group element to get it as a group expression and can then use all the usual methods such as <code class="language-plaintext highlighter-rouge">pow</code> or <code class="language-plaintext highlighter-rouge">op()</code> on it. There are even methods for usual combinations of operations such as <code class="language-plaintext highlighter-rouge">opPow()</code>. Calling <code class="language-plaintext highlighter-rouge">expr()</code> on a group itself will create an expression denoting the neutral element of that group.</p>

<p>Now, why are expressions useful here? As you can see in the code above, the for loop implements a multi-exponentiation. Without expressions, each exponentiation would be done as a single exponentiation. The expression evaluator, however, is able to automatically identify the multi-exponentiation and use an efficient multi-exponentiation algorithm to compute it. The evaluator chooses the specific algorithm to use depending on the number of different bases in the multi-exponentiation and cost of inversion in the group.</p>

<p>We do not have to stop here, however. All implemented multi-exponentiation algorithms can make use of precomputed odd powers or power products (depending on the algorithm) of the bases within. We already know these bases during key generation, so it makes sense to do this precomputation there as verification will likely be executed more often than key generation.</p>

<p>The resulting key generation function may look as follows:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// given public parameter pp and message length r</span>
    <span class="nc">Group</span> <span class="n">group2</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="na">getBilinearMap</span><span class="o">().</span><span class="na">getG2</span><span class="o">();</span>
    <span class="nc">Zp</span> <span class="n">zp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Zp</span><span class="o">(</span><span class="n">pp</span><span class="o">.</span><span class="na">getBilinearMap</span><span class="o">().</span><span class="na">getG1</span><span class="o">().</span><span class="na">size</span><span class="o">());</span>
    <span class="nc">GroupElement</span> <span class="n">group2ElementTildeG</span> <span class="o">=</span> <span class="n">group2</span><span class="o">.</span><span class="na">getUniformlyRandomNonNeutral</span><span class="o">();</span> <span class="c1">// \tilde{g} in paper</span>
    <span class="nc">ZpElement</span> <span class="n">exponentX</span> <span class="o">=</span> <span class="n">zp</span><span class="o">.</span><span class="na">getUniformlyRandomNonNeutral</span><span class="o">();</span> <span class="c1">// x in paper</span>
    <span class="nc">ZpElement</span><span class="o">[]</span> <span class="n">exponentsYi</span> <span class="o">=</span> <span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">r</span><span class="o">).</span><span class="na">mapToObj</span><span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">zp</span><span class="o">.</span><span class="na">getUniformlyRandomElement</span><span class="o">())</span>
                <span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="nc">ZpElement</span><span class="o">[]::</span><span class="k">new</span><span class="o">);</span> <span class="c1">// r random elements from \mathbb{Z}_p, y_i in paper</span>
    <span class="nc">GroupElement</span> <span class="n">group2ElementX</span> <span class="o">=</span> <span class="n">group2ElementTildeG</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="n">exponentX</span><span class="o">);</span> <span class="c1">// \tilde{X} in paper</span>
    <span class="c1">// \tilde{Y_i} in paper</span>
    <span class="nc">GroupElement</span><span class="o">[]</span> <span class="n">group2ElementsYi</span> <span class="o">=</span> 
                <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">exponentsYi</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="nl">group2ElementTildeG:</span><span class="o">:</span><span class="n">pow</span><span class="o">).</span><span class="na">toArray</span><span class="o">(</span><span class="nc">GroupElement</span><span class="o">[]::</span><span class="k">new</span><span class="o">);</span>
  
    <span class="c1">// Construct secret key</span>
    <span class="nc">PSSigningKey</span> <span class="n">sk</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PSSigningKey</span><span class="o">(</span><span class="n">exponentX</span><span class="o">,</span> <span class="n">exponentsYi</span><span class="o">);</span>

    <span class="c1">// Precompute odd powers/power products for multi-exponentiation</span>
    <span class="n">leftSideG2</span> <span class="o">=</span> <span class="n">leftSideG2</span><span class="o">.</span><span class="na">op</span><span class="o">(</span><span class="n">pk</span><span class="o">.</span><span class="na">getTildeX</span><span class="o">());</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">;</span> <span class="o">++</span><span class="no">I</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">leftSideG2</span> <span class="o">=</span> <span class="n">leftSideG2</span><span class="o">.</span><span class="na">opPow</span><span class="o">(</span><span class="n">pk</span><span class="o">.</span><span class="na">getTildeYi</span><span class="o">()[</span><span class="n">j</span><span class="o">],</span> <span class="k">new</span> <span class="nc">ExponentVariableExpr</span><span class="o">(</span><span class="s">"m_j"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">leftSideG2</span><span class="o">.</span><span class="na">precompute</span><span class="o">();</span>
    
    <span class="c1">// Construct public key</span>
    <span class="nc">PSVerificationKey</span> <span class="n">pk</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PSVerificationKey</span><span class="o">(</span><span class="n">group2ElementTildeG</span><span class="o">,</span> <span class="n">group2ElementX</span><span class="o">,</span> <span class="n">group2ElementsYi</span><span class="o">);</span>
    
    <span class="k">return</span> <span class="k">new</span> <span class="nc">SignatureKeyPair</span><span class="o">&lt;&gt;(</span><span class="n">pk</span><span class="o">,</span> <span class="n">sk</span><span class="o">);</span>
</code></pre></div></div>
<p>As you can see, the variables in the exponents of the multi-exponentiation are represented by a different type of expression, the exponent expression. Exponent expressions are not particularly interesting as computation is done in an integer ring which is very efficient already and does not need specific optimization as group algebra does (e.g. multi-exponentiations).</p>

<p>The <code class="language-plaintext highlighter-rouge">precompute()</code> call on <code class="language-plaintext highlighter-rouge">leftSideG2</code> will recognize the multiexponentiation and precompute odd powers/power products which are used by the <code class="language-plaintext highlighter-rouge">evaluate</code> call during verification. However, this is not the only thing it does. It also returns a new expression (which we ignore in the code above) which is additionally optimized by:</p>

<ul>
  <li>Rewriting the expression tree to be more efficiently computable, e.g. move pairing exponents into the pairing since exponentiation in the source groups is usually more efficient. If you want to use this, you will of course need to supply the precomputed expression to the methods that need it, in this case the verification method.</li>
  <li>Evaluating as much of the expression as possible already. This could even mean completely evaluating the expression if the expression contains no variables.</li>
</ul>

<h2 id="variable-substitution-using-value-bundles">Variable Substitution using Value Bundles</h2>

<p>Lets assume we have placed the precomputed expression in the public key and want to use it in the verification method. It contains variables in the exponents, so we will need to substitute those by the actual values before
evaluation. There exists a class that makes this very simple, the <code class="language-plaintext highlighter-rouge">ValueBundle</code> class. It allows associating variable names with values. Giving such a value bundle and an expression containing variables, we can easily obtain a new expression where the variables have been replaced by their values from the value bundle. Let’s see how this is done in the verification method we showed previously:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Given signature sigma = (sigma1, sigma2), message m = (m_0, ..., m_{r-1}), and public key pk, public parameters pp</span>
    <span class="c1">// and message length r. The public key contains our precomputed expression `leftSideG2Expr`</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sigma1</span><span class="o">.</span><span class="na">isNeutralElement</span><span class="o">())</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

    <span class="c1">// construct left side of equality check: e(sigma_1, \tilde{X} \cdot \prod{\tilde{Y}_j^{m_j}}</span>
    <span class="nc">ValueBundle</span> <span class="n">valueBundle</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ValueBundle</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">valueBundle</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"m_"</span> <span class="o">+</span> <span class="n">j</span><span class="o">,</span> <span class="n">m</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span> <span class="c1">// store messages in value bundle</span>
    <span class="o">}</span>
    <span class="nc">GroupElementExpression</span> <span class="n">leftSideG2</span> <span class="o">=</span> <span class="n">pk</span><span class="o">.</span><span class="na">getLeftSideG2Expr</span><span class="o">().</span><span class="na">substitute</span><span class="o">(</span><span class="n">valueBundle</span><span class="o">);</span> <span class="c1">// substitute variables with values</span>
    <span class="nc">GroupElementExpression</span> <span class="n">leftSide</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="na">getBilinearMap</span><span class="o">().</span><span class="na">expr</span><span class="o">(</span><span class="n">sigma1</span><span class="o">,</span> <span class="n">leftSideG2</span><span class="o">);</span>

    <span class="c1">// construct right side of equality check: e(sigma2, \tilde{g})</span>
    <span class="nc">GroupElementExpression</span> <span class="n">rightSide</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="na">getBilinearMap</span><span class="o">().</span><span class="na">expr</span><span class="o">(</span><span class="n">sigma2</span><span class="o">,</span> <span class="n">pk</span><span class="o">.</span><span class="na">getTildeG</span><span class="o">());</span>
    
    <span class="k">return</span> <span class="n">leftSide</span><span class="o">.</span><span class="na">evaluate</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">rightSide</span><span class="o">.</span><span class="na">evaluate</span><span class="o">());</span>
</code></pre></div></div>

<p>In this case, using the precomputed expression is not useful as there are no opportunities for rewriting or preevaluation. An expression may be more easily understandable if it is written in a way that is not necessarily optimal for evaluation, however, in which case precomputation helps to still enable efficient evaluation.</p>

<h1 id="boolean-expressions">Boolean Expressions</h1>

<p>Boolean expressions are similar to group or exponent expressions, just for boolean formulas. They support the usual boolean operations such as AND, OR and NOT, as well as some special equality expressions.</p>

<h2 id="group-equality-expressions">Group Equality Expressions</h2>

<p>In our implementation of the verification algorithm from [PS16], we used two <code class="language-plaintext highlighter-rouge">evaluate()</code> calls to evaluate both sides of the equality check. We can replace this by a <code class="language-plaintext highlighter-rouge">GroupEqualityExpr</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// previously: return leftSide.evaluate().equals(rightSide.evaluate());</span>
    <span class="c1">// now:</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">GroupEqualityExpr</span><span class="o">(</span><span class="n">leftSide</span><span class="o">,</span> <span class="n">rightSide</span><span class="o">).</span><span class="na">evaluate</span><span class="o">();</span>
</code></pre></div></div>
<p>This expression basically does the same thing as we did before; when evaluated, it evaluates both sides and compares them for equality. However, being an expression that is only evaluated when <code class="language-plaintext highlighter-rouge">evaluate()</code> is called, it can be precomputed and rewritten. Specifically, one can move the right side of the equality over to the left side, resulting in the equality \(x \cdot y_{-1} = 1\),
where \(x\) denotes the left side of the original equality and \(y\) the right side.</p>

<p>This is beneficial as it allows for the use of a multi-exponentiation algorithm to evaluate the left side of the equality. It can be done automatically using the <code class="language-plaintext highlighter-rouge">precompute()</code> method of the <code class="language-plaintext highlighter-rouge">BooleanExpression</code> class.</p>

<h2 id="probabilistic-and-merging">Probabilistic AND Merging</h2>

<p>Many cryptographic constructions, e.g. verification algorithms of SNARGs in the CRS model, make use of multiple equality checks to compare the results of pairing evaluations for equality. There is an optimization that can be done for these which we call “Probabilistic AND Merging”. This requires multiple group equality expressions combined with Boolean ANDs and merges them into a single group equality expression with one multi-exponentiation.
This optimization is probabilistic as it is not guaranteed to work; hence, it is disabled by default when evaluating Boolean expressions.</p>

<p>We describe how this would work for \(x_1 = 1 \wedge x_2 = 1\).
Two random exponents are chosen, we call them \(a_1\) and \(a_2\). The new
expression is then \(x_1^{a_1} \cdot x_2^{a_2} = 1\).
If we are unlucky when choosing the exponents, this equality may be true even if the original equalities are not all true, but it can improve efficiency noticably if there are many equalities.</p>

<h1 id="configuring-the-expression-evaluator">Configuring the Expression Evaluator</h1>

<p>The <code class="language-plaintext highlighter-rouge">OptGroupElementExpressionEvaluator</code> class is responsible for evaluating expressions when the <code class="language-plaintext highlighter-rouge">evaluate()</code> function is used (except for expressions over the group <code class="language-plaintext highlighter-rouge">LazyGroup</code>) and for precomputing when <code class="language-plaintext highlighter-rouge">precompute()</code> is used.</p>

<p>There are many ascepts of evaluation and precomputation that can be configured to your exact needs. The configuration of the evaluator is stored as an instance of the <code class="language-plaintext highlighter-rouge">OptGroupElementExpressionEvaluatorConfig</code> class inside the evaluator and can be retrieved using the <code class="language-plaintext highlighter-rouge">getConfig()</code> method. The config’s setter and setter methods can then be used to change the config and with that the behaviour of the evaluator. The setters are generally named <code class="language-plaintext highlighter-rouge">setX</code>, where <code class="language-plaintext highlighter-rouge">X</code> is the name of the attribute to set, and the getters are either named <code class="language-plaintext highlighter-rouge">isX</code> or <code class="language-plaintext highlighter-rouge">getX</code>, depending on whether the attribute is a Boolean or not.</p>

<h2 id="configuring-the-multi-exponentiation-algorithms">Configuring the Multi-exponentiation Algorithms</h2>

<p>The <code class="language-plaintext highlighter-rouge">OptGroupElementExpressionEvaluator</code> offers three different multi-exponentiation algorithms which are used automatically depending on the multi-exponentiation. These are an interleaved sliding algorithm, an interleaved WNAF algorithm, and a simultaneous algorithm. By setting the <code class="language-plaintext highlighter-rouge">forcedMultiExpAlgorithm</code> attribute you can force the evaluator to use a specific algorithm if you don’t like the choice it makes for you.</p>

<p>By default, caching of odd powers (for the interleaved algorithms) and power products (for the simultaneous algorithm) is turned on. However, this can potentially reduce performance if you do not use the cached powers. This can happen if a base is only used in a single exponentiation. In that case you can either disable caching for each algorithm type individually by setting the <code class="language-plaintext highlighter-rouge">enableCachingInterleavedSliding</code>, <code class="language-plaintext highlighter-rouge">enableCachingInterleavedWnaf</code> and/or <code class="language-plaintext highlighter-rouge">enableCachingSimultaneous</code> attributes, or disable caching for all algorithms using the <code class="language-plaintext highlighter-rouge">enableCachingAllAlgs</code> attribute.
Even if you are not familiar with multi-exponentiation algorithms or even regular window-based single exponentiation algorithms, benchmarking your scheme with caching enabled and disabled can make a noticable difference in runtime.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// let `expr` be some expression we want to evaluator without caching</span>
<span class="nc">OptGroupElementExpressionEvaluator</span> <span class="n">evaluator</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OptGroupElementExpressionEvaluator</span><span class="o">();</span>
<span class="n">evaluator</span><span class="o">.</span><span class="na">getConfig</span><span class="o">().</span><span class="na">setEnableCachingAllAlgs</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span> <span class="c1">// disable caching for this evaluator</span>
<span class="n">expr</span><span class="o">.</span><span class="na">evaluate</span><span class="o">(</span><span class="n">evaluator</span><span class="o">);</span> <span class="c1">// evaluate with our configured evaluator</span>
</code></pre></div></div>

<p>Furthermore, you can set the window size used for each algorithm depending on whether caching is turned on or not. For example, setting the window size of the interleaved sliding algorithm with caching enabled using the <code class="language-plaintext highlighter-rouge">windowSizeInterleavedSlidingCaching</code> attribute. Only use this if you are sure your computer can handle it, however, as increasing window size too much increases memory usage exponentially.</p>

<p>Once a multi-exponentiation contains too many bases, the simultaneous algorithm is not used anymore, instead an interleaved variant is used. This cutoff is set by the <code class="language-plaintext highlighter-rouge">simultaneousNumBasesCutoff</code> attribute. By default, it is set to <code class="language-plaintext highlighter-rouge">0</code> bases (0 means it is disabled currently, as interleaved sliding is actually faster). Above this threshold, the interleaved variants are used.
To decide whether to use the interleaved sliding or WNAF variant, the evaluator uses the <code class="language-plaintext highlighter-rouge">useWnafConstInversion</code> attribute. This is set to <code class="language-plaintext highlighter-rouge">0</code> by default, which means that if 100 inversions in the group cost as much as 0 group operations, the WNAF variant can be used (0 means it is disabled currently, as interleaved sliding is actually faster). A value of <code class="language-plaintext highlighter-rouge">50</code> would mean that inversions cost half as much as group operations.</p>

<h2 id="configuring-the-group-precomputation-phase">Configuring the Group Precomputation Phase</h2>

<p>The <code class="language-plaintext highlighter-rouge">OptGroupElementExpressionEvaluator</code> does several things in its <code class="language-plaintext highlighter-rouge">precompute()</code> method for group expressions. First, it rewrites the expression to be more efficiently evaluatable. This phase can be disabled using the <code class="language-plaintext highlighter-rouge">enablePrecomputeRewriting</code> attribute. Then it evaluates as much of the expression as possible already, controlled by the <code class="language-plaintext highlighter-rouge">enablePrecomputeEvaluation</code> attribute. Lastly, it performs caching for the later application of a multi-exponentiation algorithm which can be disabled using the <code class="language-plaintext highlighter-rouge">enablePrecomputeCaching</code> attribute.</p>

<h2 id="configuring-the-boolean-precomputation-phase">Configuring the Boolean Precomputation Phase</h2>

<p>In addition to precomputing group expressions, the evaluator also can precompute Boolean expressions. The exact optimizations that can be done are described <a href="https://github.com/upbcuk/upb.crypto.math/wiki/Expressions#boolean-expressions">here</a>. The rewriting can be disabled using <code class="language-plaintext highlighter-rouge">enablePrecomputeRewriting</code>, the Probabilistic AND Merging is controlled separately through the <code class="language-plaintext highlighter-rouge">enableProbabilisticAndMerging</code> attribute, it is disabled by default.</p>

<h2 id="a-note-regarding-efficient-caching">A Note Regarding Efficient Caching</h2>
<p>The standard way cached group elements are stored is via a hash map that maps the base to a list of cached powers for that base. This has the advantage that different <code class="language-plaintext highlighter-rouge">GroupElement</code> objects which represent the same underlying group element can always be mapped to their cached powers without having to always use the same <code class="language-plaintext highlighter-rouge">GroupElement</code> object. The disadvantage is that the computation of the hash code is computationally expensive and can, assuming you are using the efficient Mcl groups provided via <em>upb.crypto.mclwrap</em> take around 10% of the overall multi-exponentiation runtime.</p>

<p>To fix this, the library also stores cached powers in the <code class="language-plaintext highlighter-rouge">GroupElement</code> objects themselves (as long as the implementing class extends <code class="language-plaintext highlighter-rouge">AbstractGroupElement</code>). This way, accessing the hash map can be avoided and with that the hash code computation. However, for this to work you need to reuse the same <code class="language-plaintext highlighter-rouge">GroupElement</code> object in your expressions.</p>

<h1 id="references">References</h1>

<p>[PS16] David Pointcheval and Olivier Sanders. Short Randomizable Signatures. In Kazue Sako, editor, <em>Topics in Cryptology - CT-RSA 2016</em>, pages 111-126. Springer International Publishing, 2016.</p>

        
      </section>

      <footer class="page__meta">
        
        


        
      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2020 upb.crypto Documentation. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>










  </body>
</html>
